# -*- coding: utf-8 -*-
"""tgbot.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q46bCd5ECSoJBpo61EE4RgbRD7g_sI5D
"""

import telebot   
import markovify

import ufal.udpipe
from model import Model
import conllu

from collections import Counter

from nltk.parse import DependencyGraph

"""Открываем файл, в котором собраны тексты Нила Геймана."""

with open("output.txt",encoding='utf-8') as f:
    text = f.read()

m = markovify.Text(text)


model = Model('russian-taiga-ud-2.4-190531.udpipe')

def get_conllu(model, text):
    sentences = model.tokenize(text)
    for s in sentences:
        model.tag(s)
        model.parse(s)
    conllu_text = model.write(sentences, "conllu")
    return conllu_text

def get_dep_tree(text):
    trees = []
    for sent in text.split('\n\n'):
        tree = [line for line in sent.split('\n') if line and line[0] != '#']
        trees.append('\n'.join(tree))
    return trees

"""Ищем существительные вместе с номером слова, чтобы можно было искать зависимые."""

def findnoun(parsed): 
  d = DependencyGraph(parsed)
  d.root = d.nodes[0]
  nouns = []
  for word_idx in d.nodes:
    if d.nodes[word_idx]['ctag'] == 'NOUN':
      noun = d.nodes[word_idx]['word']
      id_noun = d.nodes[word_idx]['address']
      n = (noun, id_noun)
      nouns.append(n)
  return nouns

"""Ищем зависимые"""

def get_subtree(nodes, node):
    
    if not nodes[node]['deps']:
        return [node]
    
    else:
        return [node] + [get_subtree(nodes, dep) for rel in nodes[node]['deps'] 
                         if rel != 'punct'  # пунктуацию доставать не будем
                         for dep in nodes[node]['deps'][rel]]

"""Делаем "плоскую структуру""""

def flatten(l):
    flat = []
    for el in l:
        if not isinstance(el, list):
            flat.append(el)
        else:
            flat += flatten(el)
    return flat

preps = ['на', 'с', 'в', 'под', 'за']

"""Генерируем предложение и обрабатываем его."""

def getig():
  marksent = get_conllu(model, m.make_short_sentence(100))
  b = get_dep_tree(marksent)
  nouns = []
  for tree in b:
    nouns.append(findnoun(tree))
  nouns1 = [] # это на самом деле группа
  d1 = DependencyGraph(b[0])
  for i in sorted(flatten(get_subtree(d1.nodes, nouns[0][0][1]))):         
    nouns1.append(d1.nodes[i]['word'])
  for prep in preps:
    if prep not in ' '.join(nouns1):
      ig = 'и' + ' ' + ' '.join(nouns1)
    else:
      ig = ' '.join(nouns1)
  return ig

"""Запускаем бот"""

telebot.apihelper.proxy = PROXY
bot = telebot.TeleBot(TOKEN)  

@bot.message_handler(commands=['start', 'help'])
def send_welcome(message):
    bot.send_message(message.chat.id, "Здравствуйте! Это бот, который который придумывает название для вашей истории. Введите имя персонажа.")

@bot.message_handler(func=lambda m: True)
def send_len(message):
  bot.send_message(message.chat.id, '%s %s' % (message.text, getig()))
    
if __name__ == '__main__':
    bot.polling(none_stop=True)